{"question": "What is RefCell in Rust and how does it relate to interior mutability?", "answer": "RefCell is a type in Rust that allows for interior mutability by enforcing borrow checks at runtime instead of compile time."}
{"question": "What is the difference between Send and Sync in Rust?", "answer": "Send allows a type to be transferred between threads, while Sync allows a type to be shared between threads."}
{"question": "What are the tradeoffs between Box, Rc, and Arc in Rust?", "answer": "Box provides single ownership, Rc enables shared ownership with ref counting (non-thread-safe), Arc offers shared ownership with atomic ref counting (thread-safe). Use Box for unique ownership, Rc for single-threaded shared, Arc for multi-threaded shared."}
{"question": "How does the ? operator work with Result in Rust?", "answer": "The ? operator propagates errors from a Result. If the Result is Ok, it returns the value; if Err, it returns the error. Example: fn foo() -> Result<()> { let x = some_result()?; Ok(()) }"}
{"question": "How to create a concurrent HTTP GET request using Tokio in Rust?", "answer": "Use `tokio::task::spawn` with `reqwest::get`:\n\nasync fn fetch_url(url: &str) {\n    let response = reqwest::get(url).await.unwrap();\n    let body = response.text().await.unwrap();\n    println!(\"{}\", body);\n}\n\n// Spawn multiple tasks\nfor url in urls {\n    tokio::task::spawn(fetch_url(url));\n}"}
{"question": "How can you split borrows in a thread scope in Rust?", "answer": "Use thread::scope(|s| { s.spawn(|_| { ... }); s.spawn(|_| { ... }); }); to split borrows across threads."}
{"question": "How to create a custom error type in Rust with Display implementation?", "answer": "use std::fmt::{self, Display};\nstruct MyError;\nimpl Display for MyError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Custom error message\")\n    }\n}"}
{"question": "Why is Rc not Send? How to fix with Arc?", "answer": "Rc is not Send because it lacks atomic reference counting, risking data races across threads. Use Arc (Atomic Reference Counted) instead, which is Send and thread-safe."}
{"question": "What is a slice in Rust?", "answer": "A slice is a reference to a contiguous sequence of elements in a collection, like a string or array. Example: let s = \"hello\"; let slice = &s[0..2]; // \"he\""}
{"question": "How to create a shared counter using Arc<Mutex<_>> in Rust?", "answer": "use std::sync::{Arc, Mutex}; let counter = Arc::new(Mutex::new(0)); let counter_clone = Arc::clone(&counter);"}
{"question": "How to define a struct and implement a method in Rust?", "answer": "struct Point {x: i32, y: i32} impl Point { fn new(x: i32, y: i32) -> Self { Point {x, y} } }"}
{"question": "How do you use map, filter, and collect in Rust iterators?", "answer": "let nums = vec![1,2,3]; let evens: Vec<_> = nums.into_iter().filter(|x| x % 2 == 0).map(|x| x*2).collect();"}
{"question": "How to implement a lock-free counter using atomics in Rust with proper Ordering?", "answer": "use std::sync::atomic::{AtomicUsize, Ordering}; let counter = AtomicUsize::new(0); counter.fetch_add(1, Ordering::Relaxed);"}
{"question": "What is a bounded channel in Rust and how does it relate to backpressure?", "answer": "A bounded channel in Rust has a fixed capacity, and when full, senders must wait (backpressure) until space is available, preventing unbounded memory growth."}
{"question": "What happens when you assign a String to another variable in Rust?", "answer": "The original variable can no longer be used because ownership of the String is moved to the new variable."}
{"question": "How to handle lifetimes when a function returns a &str in Rust?", "answer": "Use explicit lifetimes to ensure the returned reference is valid: fn example<'a>(s: &'a str) -> &'a str { s }"}
{"question": "How to create a generic max_of function in Rust with trait bounds?", "answer": "fn max_of<T: PartialOrd>(a: T, b: T) -> T { if a > b { a } else { b } }"}
{"question": "How to send work to threads and collect results using mpsc in Rust?", "answer": "use std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n    for i in 0..3 {\n        let tx = tx.clone();\n        thread::spawn(move || { tx.send(i).unwrap(); });\n    }\n    for _ in 0..3 {\n        println!(\"Received: {}\", rx.recv().unwrap());\n    }\n}"}
{"question": "How to create a custom iterator adaptor in Rust?", "answer": "Implement the Iterator trait for a struct, defining next() with your logic. Example: struct MyIter { ... } impl Iterator for MyIter { type Item = u8; fn next(&mut self) -> Option<Self::Item> { ... } }"}
{"question": "What is the difference between &T and &mut T in Rust?", "answer": "In Rust, &T is an immutable reference to a value of type T, while &mut T is a mutable reference. &T allows reading but not modifying the value, whereas &mut T allows both reading and writing. Rust enforces strict borrowing rules to prevent data races."}
{"question": "How do you make a module public in Rust?", "answer": "Use the pub keyword before the module definition, like: pub mod my_module;"}
{"question": "Why use Arc<RwLock<T>> for read-heavy access in Rust?", "answer": "Arc<RwLock<T>> enables shared ownership with thread-safe read/write access. RwLock allows multiple readers concurrently, ideal for read-heavy scenarios, while Arc manages reference counting. Example: let data = Arc::new(RwLock::new(42));"}
{"question": "What is the difference between a String and a &str in Rust?", "answer": "String is an owned, growable string type, while &str is a borrowed, immutable string slice."}
{"question": "How do you use enums and match with Option in Rust?", "answer": "enum Message { Quit, Move {x: i32, y: i32}, Write(String), ChangeColor(i32, i32, i32)}; let msg = Message::Write(\"hello\".to_string()); match msg { Message::Write(text) => println!(\"{}\", text), _ => () }"}
{"question": "What is the difference between 'let' and 'let mut' in Rust?", "answer": "In Rust, 'let' declares an immutable variable, while 'let mut' declares a mutable variable. Example: let x = 5; // immutable\nlet mut y = 10; // mutable"}
{"question": "What is the difference between IntoIterator and Iterator in Rust for loops?", "answer": "IntoIterator is used to convert a collection into an iterator, while Iterator is the trait for the iterator itself. For loops in Rust require IntoIterator, which allows the collection to be consumed and iterated over."}
{"question": "How to use impl with explicit lifetimes when holding references in Rust?", "answer": "Use `impl Trait` with explicit lifetimes like `fn example<'a>(x: &'a i32) -> impl std::fmt::Display + 'a`."}
{"question": "When should I use async over threads in Rust?", "answer": "Use async for I/O-bound tasks with non-blocking operations, and threads for CPU-bound tasks requiring parallelism."}
